[[preface]]
[preface]
== Preface

=== Who are we and why are we writing this book?

Hi, I'm Harry.  At the end of my last book,
http://www.obeythetestinggoat.com/pages/book.html[Test-Driven Development with Python],
I found myself asking a bunch of questions about architecture -- what's the
best way of structuring your application so that it's easy to test?  More
specifically, so that your core business logic is covered by unit tests, and so
that we minimise the number of integration and end-to-end tests we need?  I
made vague references to "Hexagonal Architecture" and "Ports and Adapters" and
"Functional Core, Imperative Shell", but these weren't things I understood or
had done in practice.

And then I was lucky enough to run into Bob, who has the answers
to all these questions.

Hi, I'm Bob. I... //TODO
// DS: Maybe here would be a good place to mention where you work and the kind
// of challenges you're used to addressing.

=== Why Python?

If you're reading this book, you probably don't need convincing of the merits
of Python itself.  So it's more "why does the world need a _Python_ book for
this?", or possibly "why does the _Python_ world need a book like this?"
// TODO (DS) I had to read this sentence a couple of times through before I understood it.

The answer is about Python's popularity and maturity - although Python is
probably the world's fastest-growing programming language, and nearing the top
of the absolute popularity tables, it's only just starting to take on the kinds
of problems that the C# and Java world have been working on for years.
Startups become real businesses, web apps and scripted automations are becoming
(whisper it) enterprise software.

In the Python world, we often quote the Zen of Python:  "there should be
one--preferably on only one--obvious way to do it".  Unfortunately, as project
complexity grows, the most obvious way of doing things isn't always the way
that helps you manage complexity and evolving requirements.

None of the techniques and patterns we're going to discuss in this book are
new, but they are mostly new to the Python world.  And this book won't be
a replacement for the classics in the field like 
https://domainlanguage.com/ddd/[Evans' Domain-Driven Design]
or
https://www.martinfowler.com/books/eaa.html[Fowler's Patterns of Enterprise Application Architecture] (both of which we'll often refer to and encourage you to go and read).

But all the classic code examples in the literature do tend to be written in
Java or pass:[C++]/#, and if you're a Python person and haven't used either of those
languages in a long time (or indeed ever), it can make them quite trying.
There's a reason the latest edition of that other classic text, https://martinfowler.com/books/refactoring.html[Refactoring] is in JavaScript.

So we hope this book will make for a lightweight introduction to some
of the key architectural patterns that support Domain-Driven Design
(DDD) and event-driven microservices, that it will serve as a reference
for implementing them in a Pythonic way, and that it will serve as a
first step for those who want to do further research  in this field.


=== Who might be reading this book

Here are a few things we're assuming about you, dear reader.

We're assuming you've been close to some reasonably complex Python applications.

We're assuming you've seen some of the pain that comes with trying to manage
that complexity

We're not assuming you already know anything about DDD, or any of the
classic application architecture patterns.

We're going to be structuring our explorations of architectural patterns
by using an example app, building it up chapter by chapter.  We use TDD at
work, so we tend to show listings of tests first, followed by implementation.
If you're not used to working test-first, that may be a little strange at
first, but we hope you'll soon get used to seeing code "being used", or from
the outside, before you see how it's built on the inside.

We will be using some specific Python (3) frameworks and technologies, like
Flask, SQLAlchemy, Pytest, Docker and Redis.  If you're already familiar with
them, that won't hurt, but we don't think it's required.  One of our main aims
with this book is to build an architecture where specific technology choices
become minor implementation details.



=== Outline

==== Part 1: Dependency Inversion and Domain modelling

Chapter 1: Domain modelling and DDD::
    At some level, everyone has learned the lesson that complex business
    problems need to be reflected in code, in the form of a model of the domain.
    But why does it always seem to be so hard to do it, without getting tangled
    up with infrastructure concerns, with our web frameworks,or whatever else?
    In this chapter we give a broad overview of Domain Modelling and DDD, and
    show how to get started with a model that has no external dependencies, and
    fast unit tests.

Chapter 2-4: Repository, Service Layer and Unit of Work patterns::
    In these 3 chapters we present 3 closely related and mutually reinforcing
    patterns that support our ambition to keep the model free of extraneous
    dependencies.  We build a layer of abstraction around persistent storage,
    and we build a service layer to define the entrypoints to our system, to
    capture the primary use cases. We show how this layer makes it easy to
    build very thin entrypoints to our system, be it a Flask API or a CLI.

Chapter 5: Aggregate pattern::
    A brief return to the world of DDD, where we discuss how to choose the
    right _Aggregate_, and how this choice relates to questions of data
    integrity

==== Part 2: Event-Driven Architecture

Chapters 6-8: Event-Driven Architecture::
    We introduce three more mutually-reinforcing patterns, starting with 
    the concept of _Domain Events_, a vehicle for capturing the idea that some
    interactions with a system are triggers for others.  We use  a _Message
    Bus_ to allow actions to trigger events, and call appropriate _Handlers_.
    We move on to discuss how events can be used as a pattern for integration
    between services, in a microservices architecture. Finally we add the
    distinction between _Commands_ and events.  Our application is now
    fundamentally a message-processing system.

Chapter 9: CQRS::
    An example of Command-Query Responsibility Segregation, with and without
    events.

Chapter 10 Bootstrap, configuration root, and dependency injection::
    tidy up the dependencies and startup mess.  talk about DI vs mocks.


// TODO (DS): (General thoughts) There's nothing in the book about how to
// migrate to the pattern described here. I would have thought target readers
// are likely to be working on an existing project that isn't scaling well -
// how do they begin to apply these principles to existing architecture.
// Perhaps some advice on how to begin if you have (a) traditional three layer
// architecture or (b) big ball of mud.

=== Conventions Used in This Book

The following typographical conventions are used in this book:

_Italic_:: Indicates new terms, URLs, email addresses, filenames, and file extensions.

+Constant width+:: Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.

**`Constant width bold`**:: Shows commands or other text that should be typed literally by the user.

_++Constant width italic++_:: Shows text that should be replaced with user-supplied values or by values determined by context.


[TIP]
====
This element signifies a tip or suggestion.
====

[NOTE]
====
This element signifies a general note.
====

[WARNING]
====
This element indicates a warning or caution.
====

=== Example Code and Coding along

The book is built around a single example project (although we do sometimes
throw in other examples), and we'd like to strongly encourage you to download
that code and play around with it, to make sure you understand how everything
fits together.

Each chapter has its own branch in the code repository.  You can find
a list of them here:

https://github.com/python-leap/code/branches/all

If you want to go all the way to town, why not try and build up the code
as you read along?  Particularly if you're intending to apply some of these
patterns in your own projects, then working through a simple example can really
help you to get some safe practice.


++++
<!--PROD: Please reach out to author to find out if they will be uploading code examples to oreilly.com or their own site (e.g., GitHub). If there is no code download, delete this whole section. If there is, when you email digidist with the link, let them know what you filled in for title_title (should be as close to book title as possible, i.e., learning_python_2e). This info will determine where digidist loads the files.-->
++++

// Supplemental material (code examples, exercises, etc.) is available for
// download at link:$$https://github.com/oreillymedia/title_title$$[].

The code is made available under a Creative Commons CC-By-ND license.

If you want to re-use any of the content from this book and you have any
worries about the license terms you can contact O'Reilly 
at pass:[<a class="email" href="mailto:permissions@oreilly.com"><em>permissions@oreilly.com</em></a>].

=== O'Reilly Safari

[role = "safarienabled"]
[NOTE]
====
pass:[<a href="http://oreilly.com/safari" class="orm:hideurl"><em
class="hyperlink">Safari</em></a>] (formerly Safari Books Online) is a
membership-based training and reference platform for enterprise, government,
educators, and individuals.
====

Members have access to thousands of books, training videos, Learning Paths,
interactive tutorials, and curated playlists from over 250 publishers,
including O’Reilly Media, Harvard Business Review, Prentice Hall Professional,
Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Adobe,
Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM
Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders,
McGraw-Hill, Jones & Bartlett, and Course Technology, among others.

For more information, please visit http://oreilly.com/safari.

=== How to Contact O'Reilly

Please address comments and questions concerning this book to the publisher:

++++
<ul class="simplelist">
  <li>O’Reilly Media, Inc.</li>
  <li>1005 Gravenstein Highway North</li>
  <li>Sebastopol, CA 95472</li>
  <li>800-998-9938 (in the United States or Canada)</li>
  <li>707-829-0515 (international or local)</li>
  <li>707-829-0104 (fax)</li>
</ul>
++++

We have a web page for this book, where we list errata, examples, and any
additional information. You can access this page at
link:$$http://www.oreilly.com/catalog/<catalog page>$$[].

++++
<!--Don't forget to update the link above.-->
++++

To comment or ask technical questions about this book, send email to pass:[<a
class="email"
href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>].

For more information about our books, courses, conferences, and news, see our
website at link:$$http://www.oreilly.com$$[].

Find us on Facebook: link:$$http://facebook.com/oreilly$$[]

Follow us on Twitter: link:$$http://twitter.com/oreillymedia$$[]

Watch us on YouTube: link:$$http://www.youtube.com/oreillymedia$$[]

=== Acknowledgments

++++
<!--Fill in...-->
++++
