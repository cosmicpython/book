[[chapter_03]]
== Our first use case:  Flask API and service layer.

Like any good agile team, we're hustling to try and get an MVP out and
in front of the users to start gathering feedback.  We have the core
of our domain model and the domain service we need to allocate orders,
and we have the Repository interface for permanent storage.

Let's try and plug all the moving parts together as quickly as we
can, and then refactor towards a cleaner architecture.


=== A first end-to-end (E2E) test

No-one is interested in getting into a long terminology debate about what
counts as an E2E test vs a functional test vs an acceptance test vs an
integration test vs unit tests.  Different projects need different combinations
of tests, and we've seen perfectly successful projects just split things into
"fast tests" and "slow tests".

For now we want to write one or maybe two tests that are going to exercise
a "real" API endpoint (using HTTP) and talk to a real database. Let's call
them end-to-end tests because it's one of the most self-explanatory names.

<<first_api_test>> shows a first cut:




[[first_api_test]]
.A first API test (test_api.py)
====
[source,python]
----
def random_ref():
    return uuid.uuid4().hex[:10]

@pytest.mark.usefixtures('restart_api')
def test_api_returns_allocation_info(add_stock):
    sku1, sku2 = random_ref(), random_ref()
    batch1, batch2, batch3 = random_ref(), random_ref(), random_ref()
    add_stock([
        (batch1, sku1, 100, None),
        (batch2, sku1, 100, '2011-01-01'),
        (batch3, sku2, 100, '2011-01-02'),
    ])
    data = {
        'order_reference': random_ref(),
        'lines': {sku1: 3, sku2: 12},
    }
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 201
    assert r.json()[sku1] == batch1
    assert r.json()[sku2] == batch2
----
====

Everyone solves these problems in different ways, but you're going
to need some way of spinning up Flask, possibly in a container, and
also talking to a postgres database.  If you want to see how we did
it, check out TODO: repo tag


=== The naive implementation

Implementing things in the most obvious way, you might get something like this:


[[first_cut_flask_app]]
.First cut flask app (flask_app.py)
====
[source,python]
[role="non-head"]
----
orm.start_mappers()
get_session = sessionmaker(bind=create_engine(config.get_postgres_uri()))


app = Flask(__name__)

@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    try:
        session = get_session()
        batches = repository.BatchRepository(session).list()
        ref = request.json['order_reference']
        allocations = {}
        for sku, qty in request.json['lines'].items():
            line = model.OrderLine(ref, sku, qty)
            batch = model.allocate(line, batches)
            allocations[sku] = batch.reference

        session.commit()
        return jsonify(allocations), 201
    finally:
        session.close()
----
====


So far so good.  No need for too much more of your "architecture astronaut"
nonsense, Bob and Harry, you may be thinking.  But let's just see, not quite
all of this code was justified by a single test, was it?  Where did that
`try/finally` come from?  Where's the test for that?   And what about
adding the allocation to the repo, the current test doesn't explicitly
test for that?  Sure enough, I wrote a few more tests on the way to even this
naive solution, <<three_e2e_tests>>:


[[three_e2e_tests]]
.Actually 3 tests at the E2E layer already (test_api.py)
====
[source,python]
[role="skip"]
----
def test_api_returns_allocation_info(add_stock):
def test_api_actually_decrements_quantites(add_stock, postgres_session):
def test_api_actually_saves_allocation(add_stock, postgres_session):
----
====


=== Error conditions that require database checks

Let's add a bit of error-handling shall we?  What if we receive an order
that's already been allocated?  To do that, we need to check the database
for existing allocations for that order, something that's not really the
remit of the domain layer.

So we could dive in and start writing something like <<one_too_many_e2e_tests>>:

[[one_too_many_e2e_tests]]
.We could test at the e2e layer but...  (test_api.py)
====
[source,python]
----
@pytest.mark.usefixtures('restart_api')
def test_allocation_already_exists_error_in_json_message(add_stock):
    sku1, oref = random_ref(), random_ref()
    oref = 'dupe-' + oref
    add_stock([('warehouse', sku1, 100)])
    data = {'order_reference': oref, 'lines': {sku1: 3}}
    url = get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 201
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 400
    assert r.json()['error'] == f'Order {oref} already allocated'
----
====

But that's not really enough.  We should probably also explicitly check that
stock quantities are not decremented.  Soon our E2E tests are going to become
unwieldy, and we'll end up with an inverted test pyramid.


=== Introducing a service layer, and using FakeRepository to unit test it

let's move the orchestration stuff into a _services.py_ and use some
fakerepositories to test it:


[[first_services_test]]
.Unit testing with fakes at the services layer (test_services.py)
====
[source,python]
----
def test_error_if_allocation_already_exists():
    shipments_repo = FakeRepository()
    warehouse = Warehouse({'sku1': 100})
    warehouse_repo = FakeWarehouseRepository(warehouse)
    allocation_repo = FakeAllocationRepository([Allocation(
        order=Order('order-ref', {'sku1': 10})
    )])

    with pytest.raises(services.OrderAlreadyAllocatedException) as ex:
        services.allocate(
            'order-ref', {'sku1': 10},
            warehouse_repo, shipments_repo, allocation_repo
        )

    assert 'Order order-ref already allocated' in str(ex)
----
====


TODO: ok turns out a simple generic fakerepository may not work


[[more_fake_repositories]]
.More fake repositories (test_services.py)
====
[source,python]
----
class FakeWarehouseRepository:
    def __init__(self, warehouse):
        self.warehouse = warehouse

    def get(self):
        return self.warehouse


class FakeAllocationRepository(FakeRepository):

    def get_by_order_reference(self, order_reference):
        return next(a for a in self if a.order.reference == order_reference)
----
====


But now we can migrate some of the other E2E tests too, like the one
that checks we actually save to the repo, <<second_test>>:

TODO: discuss moving _all_ the domain unit tests to the services layer too


[[second_test]]
.A second test at the service layer (test_services.py)
====
[source,python]
----
def test_saves_new_allocation():
    shipments_repo = FakeRepository()
    warehouse = Warehouse({'sku1': 100})
    warehouse_repo = FakeWarehouseRepository(warehouse)
    allocation_repo = FakeAllocationRepository()

    allocation = services.allocate(
        'order-ref', {'sku1': 10},
        warehouse_repo, shipments_repo, allocation_repo
    )
    assert allocation == allocation_repo.pop()

    assert allocation.order.reference == 'order-ref'
    [line] = allocation.lines
    assert line.sku == 'sku1'
    assert line.source.reference == 'warehouse'
----
====

And the test that we decrement quantities too.

We'll get to a service function that looks something like <<service_function>>:

[[service_function]]
.Basic allocation service (services.py)
====
[source,python]
----
def allocate(
    order_reference: str, lines: dict,
    warehouse_repo, shipments_repo, allocation_repo
):
    try:  #<1>
        allocation_repo.get_by_order_reference(order_reference)
    except:
        # TODO: this is ugly
        pass
    else:
        raise OrderAlreadyAllocatedException(order_reference)

    order = domain_model.Order(order_reference, lines)  #<2>
    allocation = domain_model.allocate(  #<2>
        order, warehouse_repo.get(), shipments_repo.list()
    )
    allocation_repo.add(allocation)  #<3>
    return allocation
----
====

Typical service-layer functions have similar steps:

<1> We make some checks or assertions about the request against
    the current state of the world

<2> We may instantiate a domain object, and/or call a domain service

<3> We add some new state to our repository


And now our flask app looks a lot cleaner, as in <<flask_app_using_service_layer>>:


[[flask_app_using_service_layer]]
.Flask app delegating to service layer (flask_app.py)
====
[source,python]
----
@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    try:
        session = get_session()  #<1>
        allocation = services.allocate(
            request.json['order_reference'],  #<2>
            request.json['lines'],  #<2>
            warehouse_repo=repository.WarehouseRepository(session),  #<1>
            shipments_repo=repository.ShipmentRepository(session),
            allocation_repo=repository.AllocationRepository(session),
        )
        session.commit()
        return jsonify(
            {l.sku: l.source.reference for l in allocation.lines}
        ), 201  #<3>
    except services.OrderAlreadyAllocatedException as e:
        return jsonify({'error': str(e)}), 400  #<4>

    finally:
        session.close()
----
====

We see that the responsibilities of the flask app are much more minimal, and
more focused on just the web stuff:

<1> We instantiate a database session and some repository objects.
<2> We extract the user's commands from the web request and pass them
    to a domain service.
<3> And we return some JSON.

The responsibilities of the flask app are just standard web stuff: per-request
session management, parsing information out of POST parameters, response status
codes and JSON.  All the orchestration logic is in the use case / service layer,
and the domain logic stays in the domain.



=== How is our test pyramid looking?

[[test_pyramid]]
.Counting different types of test
====
[source,sh]
[role="skip"]
----
ðŸ‘‰  grep -c test_ *.py
test_allocation.py:14
test_api.py:2
test_repository.py:9
test_services.py:3
----
====

//TODO: test this too?

Not bad!  17 unit tests, 9 integration tests, and just 2 end-to-end test.


But there's still some things we're not happy with.  Passing 3 repositories
around feels awkward, and the service/orchestration layer should probably
be in charge of the commit.  We'll introduce a nice pattern to deal with
that in the next chapter.


TODO: mention commit, still not tested

TODO: mention the word "use case"

TODO: integrate folder structure stuff at some point.

