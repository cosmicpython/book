[[chapter_03_flask_api_and_service_layer]]
== Our first use case:  Flask API and service layer.

Like any good agile team, we're hustling to try and get an MVP out and
in front of the users to start gathering feedback.  We have the core
of our domain model and the domain service we need to allocate orders,
and we have the Repository interface for permanent storage.

Let's try and plug all the moving parts together as quickly as we
can, and then refactor towards a cleaner architecture.


=== A first end-to-end (E2E) test

No-one is interested in getting into a long terminology debate about what
counts as an E2E test vs a functional test vs an acceptance test vs an
integration test vs unit tests.  Different projects need different combinations
of tests, and we've seen perfectly successful projects just split things into
"fast tests" and "slow tests".

For now we want to write one or maybe two tests that are going to exercise
a "real" API endpoint (using HTTP) and talk to a real database. Let's call
them end-to-end tests because it's one of the most self-explanatory names.

<<first_api_test>> shows a first cut:

[[first_api_test]]
.A first API test (test_api.py)
====
[source,python]
----
def random_ref(prefix):
    return prefix + '-' + uuid.uuid4().hex[:10]

@pytest.mark.usefixtures('restart_api')
def test_happy_path_returns_201_and_allocated_batch(add_stock):
    sku, othersku = random_ref('s1'), random_ref('s2')
    batch1, batch2, batch3 = random_ref('b1'), random_ref('b2'), random_ref('b3')
    add_stock([
        (batch1, sku, 100, '2011-01-02'),
        (batch2, sku, 100, '2011-01-01'),
        (batch3, othersku, 100, None),
    ])
    data = {
        'orderid': random_ref('o'),
        'sku': sku,
        'qty': 3,
    }
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 201
    assert r.json()['batchid'] == batch2
----
====

Everyone solves these problems in different ways, but you're going
to need some way of spinning up Flask, possibly in a container, and
also talking to a postgres database.  If you want to see how we did
it, check out <<appendix_project_structure>>.


=== The straightforward implementation

Implementing things in the most obvious way, you might get something like this:


[[first_cut_flask_app]]
.First cut flask app (flask_app.py)
====
[source,python]
[role="non-head"]
----
orm.start_mappers()
get_session = sessionmaker(bind=create_engine(config.get_postgres_uri()))
app = Flask(__name__)

@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    session = get_session()
    batches = repository.BatchRepository(session).list()
    line = model.OrderLine(
        request.json['orderid'],
        request.json['sku'],
        request.json['qty'],
    )

    batchid = model.allocate(line, batches)

    return jsonify({'batchid': batchid}), 201
----
====


So far so good.  No need for too much more of your "architecture astronaut"
nonsense, Bob and Harry, you may be thinking.

But hang on a minute -- there's no commit.  We're not actually saving our
allocation to the database. Now we need a second test, either one that will
inspect the database state after (not very black-boxey), or maybe one that
checks we can't allocate a second line if a first should have already depleted
the batch:

[[second_api_test]]
.Test allocations are persisted (test_api.py)
====
[source,python]
[role="non-head"]
----
def test_allocations_are_persisted(add_stock):
    sku = random_ref('s1')
    batch1, batch2 = random_ref('b1'), random_ref('b2')
    order1, order2 = random_ref('o1'), random_ref('o2')
    add_stock([
        (batch1, sku, 10, '2011-01-01'),
        (batch2, sku, 10, '2011-01-02'),
    ])
    line1 = {'orderid': order1, 'sku': sku, 'qty': 10}
    line2 = {'orderid': order2, 'sku': sku, 'qty': 10}
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=line1)
    assert r.status_code == 201
    assert r.json()['batchid'] == batch1
    r = requests.post(f'{url}/allocate', json=line2)
    assert r.status_code == 201
    assert r.json()['batchid'] == batch2
----
====

Not quite so lovely, but that will force us to get a commit in.



=== Error conditions that require database checks

Let's add a bit of error-handling shall we?  What if the domain raises an
error, for a sku that's out of stock?  Or what about a sku that doesn't even
exist, that's not something the domain even knows about, nor should it.  It's
more of a sanity-check that we should implement at the database layer, before
we even invoke the domain service.

Now we're looking at two more end-to-end tests:

[[test_error_cases]]
.Yet more tests at the e2e layer...  (test_api.py)
====
[source,python]
[role="non-head"]
----
@pytest.mark.usefixtures('restart_api')
def test_400_message_for_out_of_stock(add_stock):
    sku, batch, order = random_ref('s'), random_ref('b'), random_ref('o')
    add_stock([
        (batch, sku, 10, '2011-01-01'),
    ])
    data = {'orderid': order, 'sku': sku, 'qty': 20}
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 400
    assert r.json()['message'] == f'Out of stock for sku {sku}'


@pytest.mark.usefixtures('restart_api')
def test_400_message_for_invalid_sku():
    sku, order = random_ref('s'), random_ref('o')
    data = {'orderid': order, 'sku': sku, 'qty': 20}
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 400
    assert r.json()['message'] == f'Invalid sku {sku}'
----
====

And, sure we can implement that in the flask app too:

[[flask_error_handling]]
.First cut flask app (flask_app.py)
====
[source,python]
[role="non-head"]
----
def is_valid_sku(sku, batches):
    return sku in {b.sku for b in batches}

@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    session = get_session()
    batches = repository.BatchRepository(session).list()
    line = model.OrderLine(
        request.json['orderid'],
        request.json['sku'],
        request.json['qty'],
    )

    if not is_valid_sku(line.sku, batches):
        return jsonify({'message': f'Invalid sku {line.sku}'}), 400

    try:
        batchid = model.allocate(line, batches)
    except model.OutOfStock as e:
        return jsonify({'message': str(e)}), 400

    session.commit()
    return jsonify({'batchid': batchid}), 201
----
====

But our flask app is starting to look a bit unwieldy.  And our number of
E2E tests is starting to get out of control, and soon we'll end up with an
inverted test pyramid (or "ice cream cone model" as Bob likes to call it).


=== Introducing a service layer, and using FakeRepository to unit test it

If we look at what our flask app is doing, there's quite a lot of what we
might call "orchestration" -- fetching stuff out of our repository, validating
our input against database state, handling errors, and committing in the
happy path.  Most of these things aren't anything to do with having a
web API endpoint (you'd need them if you were building a CLI for example, see
<<appendix_csvs>>), and they're not really things that need to be tested by
end-to-end tests.

It often makes sense to split out a "service layer", sometimes called
"orchestration layer' or "use case layer".  And our `FakeRepository`
will come in very useful for testing it with nice, fast unit tests:

[[first_services_test]]
.Unit testing with fakes at the services layer (test_services.py)
====
[source,python]
----
def test_returns_allocation():
    line = model.OrderLine('o1', 'sku1', 10)
    batch = model.Batch('b1', 'sku1', 100, eta=None)
    repo = FakeRepository([batch])

    result = services.allocate(line, repo, FakeSession())
    assert result == 'b1'


def test_error_for_invalid_sku():
    line = model.OrderLine('o1', 'nonexistentsku', 10)
    batch = model.Batch('b1', 'actualsku', 100, eta=None)
    repo = FakeRepository([batch])

    with pytest.raises(services.InvalidSku) as ex:
        services.allocate(line, repo, FakeSession())

    assert 'Invalid sku nonexistentsku' in str(ex)
----
====


Alongside `FakeRepository`, we also build `FakeSession` (that latter is a bit
of a temporary solution though.  We'll get rid of it and make things _even nicer_
in the next chapter, <<chapter_04_uow>>)


[[fake_repo]]
.Our fake repository (test_services.py)
====
[source,python]
----
class FakeRepository(set):

    def get(self, reference):
        return next(x for x in self if x.reference == reference)

    def list(self):
        return list(self)


class FakeSession():
    committed = False

    def commit(self):
        self.committed = True
----
====

And that lets us migrate a third test from the E2E layer, the one that
checks that we do a commit:



[[second_servicetest]]
.A second test at the service layer (test_services.py)
====
[source,python]
----
def test_commits():
    line = model.OrderLine('o1', 'sku1', 10)
    batch = model.Batch('b1', 'sku1', 100, eta=None)
    repo = FakeRepository([batch])
    session = FakeSession()

    services.allocate(line, repo, session)
    assert session.committed is True
----
====

We'll get to a service function that looks something like <<service_function>>:

[[service_function_nocommit]]
.Basic allocation service (services.py)
====
[source,python]
----
class InvalidSku(Exception):
    pass


def is_valid_sku(sku, batches):  #<2>
    return sku in {b.sku for b in batches}

def allocate(line: OrderLine, repo: BatchRepository, session) -> str:
    batches = repo.list()  #<1>
    if not is_valid_sku(line.sku, batches):  #<2>
        raise InvalidSku(f'Invalid sku {line.sku}')
    batch = model.allocate(line, batches)  #<3>
    session.commit()  #<4>
    return batch
----
====

Typical service-layer functions have similar steps:

<1> We fetch some objects from the repository

<2> We make some checks or assertions about the request against
    the current state of the world

<3> We call a domain service

<4> And if all is well, we save/update any state we've changed.

That last step is a little unsatisfactory at the moment, our services
layer is tightly coupled to our database layer, but we'll improve on
that in the next chapter.

But the essentials of the services layer are there, and our flask
app now looks a lot cleaner, <<flask_app_using_service_layer>>:


[[flask_app_using_service_layer]]
.Flask app delegating to service layer (flask_app.py)
====
[source,python]
----
@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    session = get_session()  #<1>
    repo = repository.BatchRepository(session)  #<1>
    line = model.OrderLine(
        request.json['orderid'],  #<2>
        request.json['sku'],  #<2>
        request.json['qty'],  #<2>
    )
    try:
        batchid = services.allocate(line, repo, session)  #<2>
    except (model.OutOfStock, services.InvalidSku) as e:
        return jsonify({'message': str(e)}), 400  <3>

    return jsonify({'batchid': batchid}), 201  <3>
----
====

We see that the responsibilities of the flask app are much more minimal, and
more focused on just the web stuff:

<1> We instantiate a database session and some repository objects.
<2> We extract the user's commands from the web request and pass them
    to a domain service.
<3> And we return some JSON responses with the appropriate status codes

The responsibilities of the flask app are just standard web stuff: per-request
session management, parsing information out of POST parameters, response status
codes and JSON.  All the orchestration logic is in the use case / service layer,
and the domain logic stays in the domain.


Finally we can confidently strip down our E2E tests to just two, one for
the happy path and one for the unhappy path:


[[fewer_e2e_tests]]
.E2E tests now only happy + unhappy paths (test_api.py)
====
[source,python]
----
import uuid
import pytest
import requests

import config

def random_ref(prefix):
    return prefix + '-' + uuid.uuid4().hex[:10]

@pytest.mark.usefixtures('restart_api')
def test_happy_path_returns_201_and_allocated_batch(add_stock):
    sku, othersku = random_ref('s1'), random_ref('s2')
    batch1, batch2, batch3 = random_ref('b1'), random_ref('b2'), random_ref('b3')
    add_stock([
        (batch1, sku, 100, '2011-01-02'),
        (batch2, sku, 100, '2011-01-01'),
        (batch3, othersku, 100, None),
    ])
    data = {
        'orderid': random_ref('o'),
        'sku': sku,
        'qty': 3,
    }
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 201
    assert r.json()['batchid'] == batch2


@pytest.mark.usefixtures('restart_api')
def test_unhappy_path_returns_400_and_error_message():
    sku, order = random_ref('s'), random_ref('o')
    data = {'orderid': order, 'sku': sku, 'qty': 20}
    url = config.get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 400
    assert r.json()['message'] == f'Invalid sku {sku}'

----
====

We've successfully split our tests into two broad categories: tests about web
stuff, which we implement end-to-end; and tests about orchestration stuff, which
we can test against the service layer in memory.

We could take this a step further. Since we can test the our software against
the service layer, we don't really need tests for the domain model any more.
Instead, we could write the domain-level tests from chapter one in terms of the
service layer.

.Move domain tests to service layer (test_services.py)
====
[source,python]
[role="skip"]
----
def test_prefers_warehouse_batches_to_shipments():
    warehouse_batch = Batch('wh-batch', 'sku1', 100, eta=None)
    shipment_batch = Batch('sh-batch', 'sku1', 100, eta=tomorrow)
    repo = FakeRepository([warehouse_batch, shipment_batch])
    session = FakeSession()

    line = OrderLine('oref', 'sku1', 10)

    services.allocate(line, repo, session)

    assert warehouse_batch.available_quantity == 90
----
====

Why would we want to do that?

Tests are supposed to help us change our system fearlessly, but very often
we see teams writing too many tests against their domain model. This causes
problems when they come to change their codebase, and find that they need to
update tens or even hundreds of unit tests.

This makes sense if you stop to think about the purpose of automated tests. We
use tests to enforce that some property of the system doesn't change while we're
working. We use tests to check that the API continues to return 200, that the
database session continues to commit, and that orders are still being allocated.

If we accidentally change one of those behaviours, our tests will break. The
flip side, though, is that if we want to change the design of our code, any
tests relying directly on that code will also fail.

Every line of code that we put in a test is like a blob of glue, holding the
system in a particular shape.

As we get further into the book, we'll see how the service layer forms an API
for our system that we can drive in multiple ways. Testing against this API
reduces the amount of code that we need to change when we refactor our domain
model.

// TODO: Sidebar on high vs low gear?

=== How is our test pyramid looking?

[[test_pyramid]]
.Counting different types of test
====
[source,sh]
[role="skip"]
----
ðŸ‘‰  grep -c test_ test_*.py
test_allocate.py:4
test_batches.py:8
test_services.py:3

test_orm.py:6
test_repository.py:2

test_api.py:4
----
====

//TODO: test this too?

Not bad!  15 unit tests, 8 integration tests, and just 2 end-to-end tests.


But there's still a bit of awkwardness we'd like to get rid of. The service
layer is tightly coupled to a `session` object.  In the next chapter, we'll
introduce one more pattern that works closely with _Repository_ and _Service
Layer_, the _Unit of Work_ pattern, and everything will be absolutely lovely.
You'll see!


.API and Service Layer recap
*****************************************************************
Apply the DIP to Flask as well--your API is a port::
    Your web framework should depend on your domain model and
    service layers, not the other way around.

The service layer allows your external integrations to be very thin::
    The service layer does all the work of fetching things from
    your repository, doing data validation, creating domain objects,
    invoking domain methods and services, and raising the appropriate
    errors.  This way, whether your external interface is only a very
    thin wrapper, whether it's a Flask API or a CLI that uses CSVs
    (see <<appendix_csvs>>)

*****************************************************************
